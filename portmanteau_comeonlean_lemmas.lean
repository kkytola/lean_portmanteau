/-
Copyright (c) 2021 Kalle Kyt√∂l√§. All rights reserved.
Released under Apache 2.0 license as described in the file LICENSE.
Authors: Kalle Kyt√∂l√§
-/
import measure_theory.integration
import topology.metric_space.basic
import topology.instances.real
import topology.instances.ennreal
import topology.instances.nnreal
import topology.algebra.infinite_sum
import portmanteau_definitions



noncomputable theory
open set 
open filter
open order
open_locale topological_space ennreal big_operators


namespace portmanteau



section portmanteau_comeonlean_lemmas



/-
abbreviation lim_R (s : ‚Ñï ‚Üí ‚Ñù) (l : ‚Ñù) : Prop := tendsto s at_top (ùìù l)

abbreviation lim_enn (s : ‚Ñï ‚Üí ennreal) (l : ennreal) : Prop := tendsto s at_top (ùìù l)

lemma lim_R_rw (s : ‚Ñï ‚Üí ‚Ñù) (l : ‚Ñù) : lim_R s l = tendsto s at_top (ùìù l) := by refl
-/


lemma bdd_ennval_of_le_cst' {Œ± : Type*} {f : Œ± ‚Üí ennreal} {c : nnreal} (h : f ‚â§ (Œª a , c)) :
  bdd_ennval f := by { use c , exact h , }


lemma bdd_ennval_of_le_cst {Œ± : Type*} {f : Œ± ‚Üí ennreal} {c : ennreal} (h : f ‚â§ (Œª a , c)) (hc : c ‚â† ‚ä§) :
  bdd_ennval f :=
begin
  use c.to_nnreal ,
  intros a , 
  have key := h a , 
  rwa ‚Üê ennreal.coe_to_nnreal hc at key ,
end


lemma ennreal_eq_top_of_forall_nnreal_ge (z : ennreal) : (‚àÄ (x : nnreal) , ennreal.of_real x ‚â§ z) ‚Üí z = ‚ä§ :=
begin
  contrapose ,
  intros hz ,
  push_neg ,
  have key := ennreal.lt_iff_exists_nnreal_btwn.mp (lt_top_iff_ne_top.mpr hz) ,
  cases key with x hx ,
  use x ,
  simp only [hx.1, ennreal.of_real_coe_nnreal] ,
end


lemma ennreal_eq_top_of_forall_real_ge (z : ennreal) : (‚àÄ (x : ‚Ñù) , ennreal.of_real x ‚â§ z) ‚Üí z = ‚ä§ :=
begin
  intros h ,
  apply ennreal_eq_top_of_forall_nnreal_ge ,
  intros x' ,
  exact h x' ,
end


lemma ennreal_eq_top_of_forall_nat_ge (z : ennreal) : (‚àÄ (n : ‚Ñï) , coe n ‚â§ z) ‚Üí z = ‚ä§ :=
begin
  intro h,
  suffices : (‚àÄ (x : nnreal) , ennreal.of_real x ‚â§ z) ,
  { exact ennreal_eq_top_of_forall_nnreal_ge z this , } ,
  intros x ,
  have ex : ‚àÉ (n : ‚Ñï) , x ‚â§ n := exists_nat_ge x ,
  cases ex with n hn ,
  apply le_trans (ennreal.of_real_le_of_real hn) ,
  simp only [h n, nnreal.coe_nat_cast, ennreal.of_real_coe_nat] ,
end


lemma sum_infinitely_many_ones_ennreal : ‚àë' (i : ‚Ñï), (1:ennreal) = ‚ä§ :=
begin
  apply ennreal_eq_top_of_forall_nat_ge ,
  intros n ,
  have ones_summable : summable (Œª (n : ‚Ñï) , (1:ennreal)) := ennreal.summable ,
  have key := sum_le_tsum (finset.range n) (by tidy) ones_summable ,
  have eq : ‚àë i in (finset.range n) , (1 : ennreal) = n ,
  { simp only [finset.sum_const, finset.card_range, nat.smul_one_eq_coe] , } ,
  rwa eq at key ,
end


lemma sum_infinitely_many_pos_const_ennreal' (a : nnreal) (a_pos : 0 < a) : ‚àë' (i : ‚Ñï), (a:ennreal) = ‚ä§ :=
begin
  apply ennreal_eq_top_of_forall_nnreal_ge ,
  intros b ,
  have ex' : ‚àÉ (n : ‚Ñï) , b/a ‚â§ n := exists_nat_ge _ ,
  have ex : ‚àÉ (n : ‚Ñï) , b ‚â§ n * a ,
  { cases ex' with m hm ,
    use m ,
    have key := mul_le_mul_right' hm a ,
    have cancancel : b / a * a = b , -- Hide in a corner.
    { rw [div_mul_eq_mul_div a b a , mul_comm , mul_div_right_comm a b a , div_self (ne_of_gt a_pos)] ,
      exact one_mul _ , } ,
    rwa cancancel at key , } ,
  cases ex with n hn ,
  have hn' := ennreal.coe_mono hn ,
  have eq‚ÇÄ : ((a * n : nnreal) : ennreal) = (a : ennreal)*( n: ennreal) := by simp only [ennreal.coe_nat, ennreal.coe_mul],
  nth_rewrite 1 mul_comm at eq‚ÇÄ ,
  have eq : ‚àë i in (finset.range n) , (a : ennreal) = n * a ,
  { simp only [finset.sum_const, nsmul_eq_mul, finset.card_range] , } ,
  rw ‚Üê eq at eq‚ÇÄ ,
  rw mul_comm at eq‚ÇÄ , -- Hide in another corner.
  rw eq‚ÇÄ at hn' ,
  have const_summable : summable (Œª (n : ‚Ñï) , (a:ennreal)) := ennreal.summable ,
  have key := sum_le_tsum (finset.range n) (by tidy) const_summable ,
  have eq‚ÇÅ : ennreal.of_real b = (b:ennreal) := ennreal.of_real_coe_nnreal ,
  rw eq‚ÇÅ ,
  exact le_trans hn' key ,
end


lemma sum_infinitely_many_pos_const_ennreal (a : ennreal) (a_pos : 0 < a) : ‚àë' (i : ‚Ñï), (a:ennreal) = ‚ä§ :=
begin
  by_cases a_top : a = ‚ä§ ,
  { rw a_top ,
    exact ennreal.tsum_top , } ,
  { have eq : ( a.to_nnreal : ennreal) = a := ennreal.coe_to_nnreal a_top ,
    have a_pos' : 0 < a.to_nnreal := with_top.coe_lt_iff.mp a_pos (ennreal.to_nnreal a) (eq.symm) ,
    have key := sum_infinitely_many_pos_const_ennreal' a.to_nnreal a_pos' ,
    rwa eq at key , } ,
end


lemma add_le_add_ennreal {a‚ÇÅ b‚ÇÅ a‚ÇÇ b‚ÇÇ : ennreal} (ha : a‚ÇÅ ‚â§ a‚ÇÇ) (hb : b‚ÇÅ ‚â§ b‚ÇÇ) :
  a‚ÇÅ + b‚ÇÅ ‚â§ a‚ÇÇ + b‚ÇÇ := add_le_add ha hb 


lemma le_self_add_ennreal (a b : ennreal) : a ‚â§ a + b :=
begin
  suffices : a + 0 ‚â§ a + b ,
  { simpa [this] , } ,
  apply add_le_add_ennreal _ _ ,
  { have a_eq_a : a = a := by refl ,
    exact le_of_eq a_eq_a , } ,
  simp only [zero_le, ennreal.bot_eq_zero] ,
end


lemma self_sub_le_self_sub_ennreal (a b‚ÇÅ b‚ÇÇ : ennreal) (hb : b‚ÇÇ ‚â§ b‚ÇÅ) : a - b‚ÇÅ ‚â§ a - b‚ÇÇ :=
begin
  have a_eq_a : a = a := by refl ,
  apply ennreal.sub_le_sub (le_of_eq a_eq_a) hb ,
end


lemma le_of_self_sub_le_self_sub_ennreal (a b‚ÇÅ b‚ÇÇ : ennreal) (a_ne_top : a ‚â† ‚ä§) (hb‚ÇÅ : b‚ÇÅ ‚â§ a) (hb‚ÇÇ : b‚ÇÇ ‚â§ a)
  (hb : a - b‚ÇÅ ‚â§ a - b‚ÇÇ) : b‚ÇÇ ‚â§ b‚ÇÅ :=
begin
  have eq‚ÇÅ : a - (a-b‚ÇÅ) = b‚ÇÅ := ennreal.sub_sub_cancel (lt_top_iff_ne_top.mpr a_ne_top) hb‚ÇÅ ,
  have eq‚ÇÇ : a - (a-b‚ÇÇ) = b‚ÇÇ := ennreal.sub_sub_cancel (lt_top_iff_ne_top.mpr a_ne_top) hb‚ÇÇ ,
  rw [‚Üê eq‚ÇÅ , ‚Üê eq‚ÇÇ] ,
  apply self_sub_le_self_sub_ennreal a (a-b‚ÇÇ) (a-b‚ÇÅ) hb ,
end


lemma sub_larger_ennreal (a b : ennreal) (hab : a ‚â§ b) : a - b = 0 :=
begin
  exact ennreal.sub_eq_zero_iff_le.mpr hab ,
end


lemma fin_pos_nnreal_of_fin_pos_ennreal 
  (Œµ : ennreal) (Œµ_pos : 0 < Œµ) (Œµ_fin : Œµ ‚â† ‚ä§) :
    0 < Œµ.to_nnreal :=
begin
  set Œµ' := Œµ.to_nnreal with hŒµ' ,
  have eq : ennreal.of_nnreal_hom Œµ' = Œµ := ennreal.coe_to_nnreal Œµ_fin ,
  by_contra contra ,
  simp only [not_lt, le_zero_iff] at contra ,
  rw contra at eq ,
  simp only [ennreal.coe_of_nnreal_hom, ennreal.coe_zero] at eq,
  rw ‚Üêeq at Œµ_pos ,
  have key := ne_of_lt Œµ_pos ,
  contradiction ,
end


lemma ennreal_lt_top_iff_ne_top (z : ennreal) : 
  z < ‚ä§ ‚Üî z ‚â† ‚ä§ 
    := lt_top_iff_ne_top


lemma ennreal_lt_top_of_ne_top (z : ennreal) (hz : z < ‚ä§) : z ‚â† ‚ä§ 
    := (ennreal_lt_top_iff_ne_top z).mp hz


lemma ennreal_ne_top_of_lt_top (z : ennreal) (hz : z ‚â† ‚ä§) : z < ‚ä§
    := (ennreal_lt_top_iff_ne_top z).mpr hz


lemma lt_add_pos_ennreal (z Œµ : ennreal) (hz : z ‚â† ‚ä§) (Œµ_pos : 0 < Œµ) : 
  z < z + Œµ :=
begin
  by_cases Œµ_fin : Œµ = ‚ä§ ,
  { simp only [Œµ_fin, ennreal.add_top] ,
    exact lt_top_iff_ne_top.mpr hz , } ,
  have key := ((@ennreal.add_lt_add_iff_left z) Œµ 0 ( (ennreal_lt_top_iff_ne_top z).mpr hz)).mpr Œµ_pos,
  simp only [add_zero] at key ,
  exact key ,
end


lemma nbhd_top_ennreal' (U : set ennreal) (hU : U ‚àà ùìù ‚àû) :
  ‚àÉ (a : nnreal) , Ioi (a : ‚Ñù‚â•0‚àû) ‚äÜ U :=
begin
  have ns := ennreal.nhds_top' ,
  rw ns at hU ,
  rw mem_infi_iff' at hU ,
  rcases hU with ‚ü® I , ‚ü® I_fin , ‚ü®v , ‚ü® V_supset_Ioi , inter_V_subset_U ‚ü© ‚ü© ‚ü© ‚ü© ,
  have ex_ub : ‚àÉ (b : nnreal) , ‚àÄ i ‚àà I , i ‚â§ b 
    := exists_upper_bound_image I (Œª (b : nnreal), b) I_fin , -- don't go to plain sight!
  cases ex_ub with b hb ,
  use b ,
  intros x hx ,
  rw mem_Ioi at hx,
  have key : x ‚àà ‚ãÇ (i ‚àà I) , (v i) ,
  { rw mem_bInter_iff ,
    intros i hi ,
    have key := V_supset_Ioi i hi ,
    rw mem_principal_sets at key ,
    exact key (lt_of_le_of_lt (ennreal.coe_mono (hb i hi)) hx) , } ,
  exact inter_V_subset_U key ,
end


lemma nbhd_top_ennreal (U : set ennreal) (hU : U ‚àà ùìù ‚àû) :
  ‚àÉ (a < ‚ä§) , Ioi (a : ‚Ñù‚â•0‚àû) ‚äÜ U :=
begin
  have key := nbhd_top_ennreal' U hU ,
  cases key with a' ha' ,
  use a' ,
  exact ‚ü® ennreal.coe_lt_top , ha' ‚ü© ,
end


lemma continuous_const_sub_nnreal (a : nnreal) :
  continuous (Œª (x : nnreal) , a-x ) :=
begin
  set sub := (Œª (p : nnreal √ó nnreal) , p.1 - p.2) with h_sub ,
  set to_pair := (Œª (x : nnreal) , (‚ü®a,x‚ü© : nnreal √ó nnreal)) with h_to_pair ,
  have cont_to_pair : continuous to_pair 
    := @continuous.prod_mk nnreal nnreal nnreal _ _ _ (Œª x , a) (Œª x , x) (continuous_const) (continuous_id') ,
  have eq : sub ‚àò to_pair = (Œª (x : nnreal) , a-x ) := by refl , -- hide in corners
  rw ‚Üê eq ,
  exact continuous.comp continuous_sub cont_to_pair ,
end

-- Why could I not find (a symmetric version of) this?
lemma equality_of_restrictions {Œ≥ Œ¥ : Type*} [topological_space Œ≥] {f g : Œ≥ ‚Üí Œ¥} {G : set Œ≥} {x‚ÇÄ : Œ≥} (hfg : ‚àÄ (x ‚àà G) , f x = g x) (hx‚ÇÄ : x‚ÇÄ ‚àà G) :
  map f (ùìù[G] x‚ÇÄ) ‚â§ map g (ùìù[G] x‚ÇÄ) :=
begin
  intros V hV ,
  rcases hV with ‚ü® U , hU_nhd , ‚ü® T , ‚ü® hT_princ , hUT ‚ü© ‚ü©  ‚ü© ,
  use U ,
  split , 
  { exact hU_nhd , } ,
  use G ,
  split , 
  { exact mem_principal_self G , } ,
  intros y hy ,
  have y_in_G : y ‚àà G := mem_of_mem_inter_right hy ,
  rw mem_preimage ,
  rw (hfg y (mem_of_mem_inter_right hy)) ,
  have y_in_bigger : y ‚àà U ‚à© T := inter_subset_inter_right U hT_princ hy , 
  exact hUT y_in_bigger , 
end


lemma sub_ennreal_nnreal_continuous_on_ne_top : 
  continuous_on (Œª p : ennreal √ó nnreal, p.1 - p.2) { p : ennreal √ó nnreal | p.1 ‚â† ‚ä§ } :=
begin
  set proj : ennreal √ó nnreal ‚Üí nnreal √ó nnreal := Œª p , ‚ü®ennreal.to_nnreal(p.1), p.2‚ü© with h_proj ,
  have proj_cont : continuous_on proj { p : ennreal √ó nnreal | p.1 ‚â† ‚ä§ } ,
  { have id_cont : continuous_on (Œª (z : nnreal) , z) univ := continuous_on_id ,
    have eq_fun : proj = prod.map ennreal.to_nnreal (Œª (z : nnreal) , z) := by refl ,
    have eq_set : { p : ennreal √ó nnreal | p.1 ‚â† ‚ä§ } = { z : ennreal | z ‚â† ‚ä§ }.prod (univ : set nnreal) := by tidy ,
    rw [eq_fun, eq_set] ,
    exact continuous_on.prod_map ennreal.continuous_on_to_nnreal id_cont , } ,
  set sub := (Œª p : nnreal √ó nnreal, p.1 - p.2) with h_sub ,
  have eq : ‚àÄ p ‚àà { p : ennreal √ó nnreal | p.1 ‚â† ‚ä§ } , (Œª p : ennreal √ó nnreal, p.1 - p.2) p = (coe ‚àò sub ‚àò proj) p ,
  { intros p hp ,
    rw [h_proj , h_sub] ,
    dsimp ,
    simp only [mem_set_of_eq, ne.def] at hp ,
    have coes : p.fst = (p.fst.to_nnreal : ennreal) ,
    { simp only [hp, ne.def, not_false_iff, ennreal.coe_to_nnreal] , } ,
    nth_rewrite 0 coes ,
    apply ennreal.coe_sub.symm , } ,
  suffices : continuous_on (coe ‚àò sub ‚àò proj) { p : ennreal √ó nnreal | p.1 ‚â† ‚ä§ } ,
  { exact (continuous_on_congr (eq_on.symm eq)).mp this , } ,
  have cont := continuous.comp_continuous_on continuous_sub proj_cont ,
  apply continuous.comp_continuous_on (ennreal.continuous_coe) cont ,
end


lemma sub_sum_nnreal (a b c : nnreal) : a - (b + c) = a - b - c :=
begin
  have lhs : a - (b + c) = (a.val - b.val - c.val).to_nnreal , --nnreal.of_real (a.val - b.val - c.val) ,
  { rw nnreal.sub_def ,
    apply congr_arg ,
    cases c, 
    cases b, 
    cases a, 
    dsimp at * ,
    ring , } ,
  have rhs : a - b - c = (a.val - b.val - c.val).to_nnreal , -- nnreal.of_real (a.val - b.val - c.val) ,
  { by_cases hab : b ‚â§ a ,
    { have hab' : b.val ‚â§ a.val := hab ,
      have hab'' : 0 ‚â§ a.val - b.val := by linarith ,
      have a_sub_b_val : (a-b).val = a.val - b.val ,
      { have mx : max (a.val - b.val) 0 = a.val - b.val := max_eq_left hab'' ,
        rw nnreal.sub_def ,
        unfold real.to_nnreal ,
        simp_rw mx ,
        exact mx , } ,
      set d := a-b with hd ,
      rw ‚Üêa_sub_b_val ,
      rw nnreal.sub_def ,
      apply congr_arg ,
      refl , } ,
    { simp only [not_le] at hab ,
      have le : a ‚â§ b := le_of_lt hab , -- Such reasoning,
      have le' : a.val ‚â§ b.val := le , -- obviously, is the 
      have le'' : a.val - b.val ‚â§ 0 := by linarith , -- very
      have c_nn : 0 ‚â§ c.val := c.prop , -- heart of the asserted
      have le''' : a.val - b.val - c.val ‚â§ 0 := by linarith , -- fact.
      have mx : max (a.val - b.val - c.val) 0 = 0 := max_eq_right le''' ,
      have a_sub_b : a - b = 0 := nnreal.sub_eq_zero le ,
      have z_sub_c : 0 - c = 0 := le_zero_iff.mp (nnreal.sub_le_self) ,
      rw [a_sub_b , z_sub_c] ,
      unfold real.to_nnreal ,
      simp_rw mx ,
      refl , } ,
  } ,
  rw [lhs, rhs] ,
end


lemma sub_sum_ennreal (a b c : ennreal) : a - (b + c) = a - b - c :=
begin
  by_cases fin : b < ‚àû ‚àß c < ‚àû ,
  { have b_eq : (b.to_nnreal : ennreal) = b := ennreal.coe_to_nnreal (ennreal.lt_top_iff_ne_top.mp fin.left) ,
    have c_eq : (c.to_nnreal : ennreal) = c := ennreal.coe_to_nnreal (ennreal.lt_top_iff_ne_top.mp fin.right) ,
    rw [‚Üêb_eq, ‚Üêc_eq] ,
    set Œπ := (coe : nnreal ‚Üí ennreal) with hŒπ ,
    set b' := b.to_nnreal with hb' ,
    set c' := c.to_nnreal with hc' ,
    have eq‚ÇÇ : Œπ (b'+c') = Œπ b' + Œπ c' := @ennreal.coe_add b' c' ,
    have sum_fin : b + c < ‚ä§ 
      := by simp only [fin.left, fin.right, ennreal.add_lt_top, and_self] ,
    by_cases a_top : a = ‚ä§ ,
    { rw a_top ,
      have sum_ne_top := ennreal.lt_top_iff_ne_top.mp sum_fin ,
      have lhs : ‚ä§ - Œπ (b'+c') = ‚ä§ := ennreal.top_sub_coe , -- to a corner
      have rhs‚ÇÅ : ‚ä§-(Œπ b') = ‚ä§ := ennreal.top_sub_coe , 
      have rhs‚ÇÇ : ‚ä§-(Œπ c') = ‚ä§ := ennreal.top_sub_coe ,
      rw [rhs‚ÇÅ , rhs‚ÇÇ , ‚Üêeq‚ÇÇ , lhs] , } ,
    { have a_eq : (a.to_nnreal : ennreal) = a := ennreal.coe_to_nnreal a_top ,
      rw [‚Üêa_eq] ,
      set a' := a.to_nnreal with ha' ,
      have key := sub_sum_nnreal a.to_nnreal b.to_nnreal c.to_nnreal ,
      have key' := congr_arg (coe : nnreal ‚Üí ennreal) key , -- quickly, to another corner
      have eq‚ÇÅ : Œπ (a' - (b'+c')) = (Œπ a') - (Œπ (b'+c')) := @ennreal.coe_sub (b'+c') a' ,
      have eq‚ÇÉ : Œπ (a' - b' - c') = (Œπ (a' - b')) - (Œπ (c')) := @ennreal.coe_sub c' (a'-b') ,
      have eq‚ÇÑ : Œπ (a' - b') = (Œπ a') - (Œπ b') := @ennreal.coe_sub b' a' ,
      rwa [‚Üêeq‚ÇÇ, ‚Üêeq‚ÇÑ, ‚Üêeq‚ÇÅ, ‚Üêeq‚ÇÉ] , } ,
  } ,
  { rw not_and_distrib at fin , -- hide
    cases fin with not_fin not_fin ; simp only [not_lt, top_le_iff] at not_fin ,
    { rw [not_fin , ennreal.top_add] ,
      simp only [ennreal.sub_infty, ennreal.zero_sub] , } ,
    { rw [not_fin , ennreal.add_top] ,
      simp only [ennreal.sub_infty, ennreal.zero_sub] , } ,
  } ,
end


lemma continuous_sub_ennreal_nnreal : 
  continuous (Œª p : ennreal √ó nnreal, p.1 - p.2) :=
begin
  apply continuous_iff_continuous_at.mpr ,
  intros p ,
  by_cases fst_top : p.fst = ‚ä§ ,
  { intros V hV ,
    simp_rw fst_top at hV ,
    simp only [ennreal.top_sub_coe] at hV ,
    have V_super := nbhd_top_ennreal' V hV ,
    cases V_super with v hv ,
    set U := set.prod (Ioi (p.2 + v + 1 : ennreal)) (Iio (p.2 + 1)) with hU ,
    have lt‚ÇÅ : (‚ä§ : ‚Ñù‚â•0‚àû) ‚àà (Ioi (p.2 + v + 1 : ennreal)) ,
    { simp only [true_and, ennreal.coe_lt_top, mem_Ioi, ennreal.add_lt_top] ,
      exact dec_trivial , } ,
    have nbhd‚ÇÅ : Ioi (p.2+v+1 : ennreal) ‚àà ùìù p.1,
    { rw fst_top ,
      --exact is_open.mem_nhds (is_open_Ioi) lt‚ÇÅ ,
      exact Ioi_mem_nhds lt‚ÇÅ , } ,
    have nbhd‚ÇÇ : Iio (p.2+1) ‚àà ùìù p.2 := is_open.mem_nhds (is_open_Iio) (by simp only [mem_Iio, lt_add_iff_pos_right, zero_lt_one]) ,
      --:= mem_nhds_sets (is_open_Iio) (by simp only [mem_Iio, lt_add_iff_pos_right, zero_lt_one]) ,
    have nbhd := prod_is_open.mem_nhds nbhd‚ÇÅ nbhd‚ÇÇ ,
      --: set.prod (Ioi (p.2 + v + 1 : ennreal)) (Iio (p.2 + 1)) ‚àà ùìù p
      --:= by sorry , -- the above works in another version of mathlib
    rw [‚ÜêhU , prod.mk.eta] at nbhd , --works in another version of mathlib
    --have nbhd : U ‚àà ùìù p := by sorry , -- again, use the above in a fresh mathlib
    set f := (Œª p : ennreal √ó nnreal, p.1 - p.2) with hf ,
    have ss : U ‚äÜ f‚Åª¬π' V ,
    { rintros q ‚ü® hq‚ÇÅ , hq‚ÇÇ‚ü© ,
      simp only [mem_Ioi] at hq‚ÇÅ ,
      simp only [mem_Iio] at hq‚ÇÇ ,
      have hq‚ÇÇ' : (q.snd : ennreal) < p.snd + 1 := ennreal.coe_lt_coe.mpr hq‚ÇÇ ,
      have hq‚ÇÅ' : (p.snd : ennreal) + 1 < q.fst - v ,
      { have le : (v : ennreal) ‚â§ q.fst ,
        { apply le_of_lt _ ,
          calc (v : ennreal) ‚â§ (v : ennreal) + (1 + p.snd) : le_self_add_ennreal _ _
          ... = (p.snd : ennreal) + v + 1                  : by ring
          ... < q.fst                                      : hq‚ÇÅ , } ,
        have eq : q.fst - v + v = q.fst := ennreal.sub_add_cancel_of_le le ,
        have eq' : (p.snd : ennreal) + 1 + v = (p.snd : ennreal) + v + 1 := by ring ,
        rw [‚Üêeq , ‚Üêeq'] at hq‚ÇÅ ,
        exact (ennreal.add_lt_add_iff_right (@ennreal.coe_lt_top v)).mp hq‚ÇÅ , } ,
      have gt : (v : ennreal) < f q ,
      { rw hf ,
        dsimp ,
        have lt := lt_trans hq‚ÇÇ' hq‚ÇÅ' ,
        have lt' := ennreal.zero_lt_sub_iff_lt.mpr lt ,
        have rw‚ÇÄ : q.fst - v - q.snd = q.fst - q.snd - v ,
        { rw [‚Üê(sub_sum_ennreal _ _ _) , ‚Üê(sub_sum_ennreal _ _ _) , add_comm ] , } ,
        rw rw‚ÇÄ at lt' ,
        apply ennreal.zero_lt_sub_iff_lt.mp lt' ,
      } ,
      exact hv gt , } ,
    apply (ùìù p).sets_of_superset nbhd ss , } ,
  { intros V hV ,
    dsimp at hV ,
    have key := sub_ennreal_nnreal_continuous_on_ne_top p fst_top hV ,
    rcases key with ‚ü® U , U_nbhd , ‚ü® T , ‚ü® hT , hUT ‚ü© ‚ü© ‚ü© ,
    set S := { p : ennreal √ó nnreal | p.1 ‚â† ‚ä§ } with hS ,
    rw mem_principal_sets at hT ,
    have S_prod : S = {z : ennreal | z ‚â† ‚ä§}.prod (univ : set nnreal) ,
    { ext q ,
      simp only [and_true, mem_univ, mem_set_of_eq, mem_prod] , } ,
    have nbhd‚ÇÅ : {z : ennreal | z ‚â† ‚ä§} ‚àà ùìù p.fst := is_open.mem_nhds (is_open_ne) (fst_top) , -- mem_nhds_sets (is_open_ne) (fst_top) ,
    have nbhd‚ÇÇ : (univ : set nnreal) ‚àà ùìù p.snd := is_open.mem_nhds (is_open_univ) (mem_univ _) ,
    have S_nbhd : {z : ennreal | z ‚â† ‚ä§}.prod (univ : set nnreal) ‚àà ùìù (‚ü®p.1, p.2‚ü© : ennreal √ó nnreal) 
      := prod_is_open.mem_nhds nbhd‚ÇÅ nbhd‚ÇÇ , -- prod_mem_nhds_sets nbhd‚ÇÅ nbhd‚ÇÇ ,
    rw [‚ÜêS_prod , prod.mk.eta] at S_nbhd ,
    have US_nbhd : U ‚à© S ‚àà ùìù p := (ùìù p).inter_sets U_nbhd S_nbhd ,
    have US_ss_UT : U ‚à© S ‚äÜ U ‚à© T := inter_subset_inter_right U hT ,
    have UT_nbhd : U ‚à© T ‚àà ùìù p := (ùìù p).sets_of_superset US_nbhd US_ss_UT ,
    apply (ùìù p).sets_of_superset UT_nbhd hUT , } ,
end


-- Remark: 
-- This is not even the right generality for the continuity of
-- subtraction on a subset of `ennreal √ó ennreal`. I guess we
-- have continuity on the complement of the singleton `{‚ü®‚àû,‚àû‚ü©}`.
-- With that, a few of the subsequent corner-hidings would simplify.
-- But I had surprisingly hard time working with ennreals and 
-- subtraction, so I gave up and just aimed at a sorry-free (TM)
-- exercise...
lemma continuous_sub_ennreal_ennreal_snd_ne_top : 
  continuous_on (Œª p : ennreal √ó ennreal, p.1 - p.2) { p : ennreal √ó ennreal | p.snd ‚â† ‚àû} :=
begin
  have g_cont := continuous_sub_ennreal_nnreal ,
  set g := (Œª p : ennreal √ó nnreal, p.1 - p.2) with hg ,
  set f := (Œª p : ennreal √ó ennreal, p.1 - p.2) with hf ,
  set œÜ := (Œª p : ennreal √ó ennreal, ( ‚ü®p.1 , (p.2).to_nnreal ‚ü© : ennreal √ó nnreal ) ) with hœÜ ,
  set S := { p : ennreal √ó ennreal | p.snd ‚â† ‚àû} with hS ,
  have œÜ_cont : continuous_on œÜ S ,
  { have key‚ÇÅ' : continuous (Œª (z : ennreal) , z ) := continuous_id' ,
    have key‚ÇÅ : continuous_on (Œª (z : ennreal) , z ) univ := continuous.continuous_on key‚ÇÅ' ,
    have key‚ÇÇ := ennreal.continuous_on_to_nnreal ,
    have œÜ_prod_map : œÜ = prod.map (Œª (z : ennreal) , z ) ennreal.to_nnreal := by refl ,
    have S_prod_set : S = (univ : set ennreal).prod {w : ennreal | w ‚â† ‚àû}, 
    { simp only [eq_self_iff_true] at hS , 
      ext p, 
      cases p, 
      dsimp , 
      simp only [true_and, mem_univ] , } ,
    rw [œÜ_prod_map , S_prod_set] ,
    exact continuous_on.prod_map key‚ÇÅ key‚ÇÇ , } ,
  have comp_cont : continuous_on (g ‚àò œÜ) S := continuous.comp_continuous_on g_cont œÜ_cont ,
  have agree : ‚àÄ p ‚àà S , f p = (g ‚àò œÜ) p ,
  { intros p hpS ,
    rw [hf , hg , hœÜ ] ,
    simp only [function.comp_app] ,
    rw ennreal.coe_to_nnreal hpS , } ,
  have pfun_eq : pfun.res f S = pfun.res (g ‚àò œÜ) S ,
  { ext ,
    rw pfun.mem_res ,
    rw pfun.mem_res ,
    split ,
    { rintros ‚ü® hx , val ‚ü© ,
      rw agree x hx at val ,
      exact ‚ü® hx , val ‚ü© , } ,
    { rintros ‚ü® hx , val ‚ü© ,
      rw ‚Üê agree x hx at val ,
      exact ‚ü® hx , val ‚ü© , } ,
  } ,
  intros p hp ,
  rw continuous_within_at_iff_ptendsto_res ,
  rw [pfun_eq , agree p hp] ,
  rw ‚Üê continuous_within_at_iff_ptendsto_res ,
  exact comp_cont p hp ,
end


-- Remark: This should get an easier proof from the right
-- continuity result of subtraction on ennreals.
lemma continuous_on_const_sub_ennreal (a : ennreal) (a_ne_top : a ‚â† ‚ä§) :
  continuous_on (Œª (x : ennreal) , a-x ) {z : ennreal | z ‚â† ‚ä§} :=
begin
  set f := (Œª (x : ennreal) , a-x ) with hf ,
  set S := { z : ennreal | z ‚â† ‚ä§ } with hS ,
  have cont_cast : continuous_on ennreal.to_nnreal S := ennreal.continuous_on_to_nnreal ,
  set f‚ÇÄ := (Œª (x : nnreal) , a.to_nnreal-x ) with hf‚ÇÄ ,
  have cont_f‚ÇÄ : continuous f‚ÇÄ := continuous_const_sub_nnreal (ennreal.to_nnreal a) ,
  have cont_f‚ÇÄ' : continuous_on f‚ÇÄ univ := continuous.continuous_on cont_f‚ÇÄ ,
  have cont_comp' := continuous_on.comp cont_f‚ÇÄ' cont_cast (by simp only [preimage_univ, subset_univ]) ,
  have cont_comp := continuous.comp_continuous_on ennreal.continuous_coe cont_comp' ,
  have eq‚ÇÄ : ( ‚àÄ (z ‚àà S) , f z = (coe ‚àò f‚ÇÄ ‚àò ennreal.to_nnreal) z ) ,
  { intros z hz ,
    rw [hf , hf‚ÇÄ] ,
    dsimp ,
    have a_eq := ennreal.coe_to_nnreal a_ne_top ,
    have z_eq := ennreal.coe_to_nnreal hz ,
    rw [‚Üêa_eq , ‚Üêz_eq] ,
    apply ennreal.coe_sub.symm , } ,
  intros z hzS V hV ,
  have hV' := hV ,
  rw (eq‚ÇÄ z hzS) at hV' ,
  specialize cont_comp z hzS hV' ,
  have key := equality_of_restrictions eq‚ÇÄ hzS ,
  exact key cont_comp ,
end


-- Remark: This also should get an easier proof from the right
-- continuity result of subtraction on ennreals.
lemma continuous_const_sub_ennreal (a : ennreal) (a_ne_top : a ‚â† ‚ä§) :
  continuous (Œª (x : ennreal) , a-x ) :=
begin
  set f := (Œª (x : ennreal) , a-x ) with hf ,
  apply continuous_iff_continuous_at.mpr ,
  intros x ,
  by_cases hx : x = ‚ä§ ,
  { rw hx ,
    have mem_Ioi : ‚ä§ ‚àà Ioi a := ennreal.lt_top_iff_ne_top.mpr a_ne_top ,
    have open_Ioi : is_open (Ioi a) := is_open_Ioi , 
    have nhd_Ioi : Ioi a ‚àà ùìù ‚ä§ := is_open.mem_nhds open_Ioi mem_Ioi , --mem_nhds_sets open_Ioi mem_Ioi ,
    intros V hV ,
    have val_at_top : f ‚ä§ = 0 := by simp only [ennreal.sub_eq_zero_iff_le, le_top] ,
    rw val_at_top at hV ,
    have mem_V : (0 : ennreal) ‚àà V ,
    { exact mem_of_mem_nhds hV , } ,
    have ss_preim : Ioi a ‚äÜ f‚Åª¬π' V ,
    { intros z hz ,
      have val : f z = 0 := ennreal.sub_eq_zero_iff_le.mpr (le_of_lt hz) ,
      rwa ‚Üê val at mem_V , } ,
    exact (ùìù ‚ä§).sets_of_superset nhd_Ioi ss_preim , } ,
  { set S := { z : ennreal | z ‚â† ‚ä§ } with hS ,
    have nbhd : S ‚àà (ùìù x) ,
    { have opn : is_open S := is_open_ne ,
      --exact mem_nhds_sets opn good ,
      exact is_open.mem_nhds opn hx , } ,
    suffices : continuous_on f S ,
    { intros V hV ,
      have key := this x hx hV ,
      rcases key with ‚ü® U , U_nhd , ‚ü® T , hT , hUT‚ü© ‚ü© ,
      rw mem_principal_sets at hT ,
      have T_nbhd : T ‚àà (ùìù x) := (ùìù x).sets_of_superset nbhd hT ,
      have nbhd‚ÇÄ : U ‚à© T ‚àà (ùìù x) := inter_mem_sets U_nhd T_nbhd ,
      rw mem_map ,      
      apply (ùìù x).sets_of_superset nbhd‚ÇÄ hUT , } ,
    exact continuous_on_const_sub_ennreal a a_ne_top , } ,
end


lemma lim_enn_of_lim_R {s : ‚Ñï ‚Üí ‚Ñù} {l : ‚Ñù} (hlim : tendsto s at_top (ùìù l)) : 
  tendsto (ennreal.of_real ‚àò s) at_top (ùìù (ennreal.of_real l))
    := ennreal.tendsto_of_real hlim 


lemma nnreal_nbhd_finite_ennreal (x : ennreal) :
  x ‚â† ‚ä§ ‚Üí { z : ennreal | z ‚â† ‚ä§ } ‚àà ùìù x :=
begin
  intros hx ,
  have op : is_open { z : ennreal | z ‚â† ‚ä§ } := is_open_ne ,
  --TODO: depending on mathlib version, one of the following works...
  --exact mem_nhds_sets op hx ,
  exact is_open.mem_nhds op hx ,
end


lemma ennreal_to_nnreal_continuous_on_nnreal :
  continuous_on ennreal.to_nnreal { z : ennreal | z ‚â† ‚ä§ } :=
begin
  exact ennreal.continuous_on_to_nnreal , 
end


lemma ennreal_to_real_continuous_on_nnreal :
  continuous_on ennreal.to_real { z : ennreal | z ‚â† ‚ä§ } :=
begin
  have eq : ennreal.to_real = nnreal.to_real_hom ‚àò ennreal.to_nnreal := by refl ,
  rw eq ,
  intros z hz ,
  have cont_at_nnreal 
    := continuous_on.continuous_at ennreal.continuous_on_to_nnreal (nnreal_nbhd_finite_ennreal z hz), 
  apply @tendsto.comp _ _ _ _ _ _ (ùìù (ennreal.to_nnreal z)) _ ,
  { simp only [nnreal.coe_to_real_hom, nnreal.tendsto_coe] ,
    intros U hU ,
    assumption , } ,
  { exact tendsto_inf_left cont_at_nnreal , } ,
end


lemma ennreal_ne_top_of_le_nnreal {c : nnreal} {x : ennreal} (h_le : x ‚â§ c) : x ‚â† ‚ä§ :=
begin
  by_contra contra ,
  rw not_not at contra ,
  rw contra at h_le ,
  simp only [ennreal.not_top_le_coe] at h_le ,
  exact h_le , 
end


lemma finval_of_bdd_ennval {Œ± : Type*} {f : Œ± ‚Üí ennreal} :
  bdd_ennval f ‚Üí ‚àÄ (a : Œ±) , f(a) ‚â† ‚ä§ :=
begin
  intros f_bdd a ,
  cases f_bdd with c hc ,
  exact ennreal_ne_top_of_le_nnreal (hc a) ,
end


lemma bdd_Rval_add {Œ± : Type*} {f g : Œ± ‚Üí ‚Ñù}
  (f_bdd : bdd_Rval f) (g_bdd : bdd_Rval g) : bdd_Rval (f+g) :=
begin
  cases f_bdd with c hc ,
  cases g_bdd with d hd ,
  use (c+d) ,
  intros x ,
  apply le_trans (abs_add (f(x)) (g(x))) (add_le_add (hc x) (hd x)) ,
end


lemma bdd_ennval_add {Œ± : Type*} {f g : Œ± ‚Üí ennreal}
  (f_bdd : bdd_ennval f) (g_bdd : bdd_ennval g) : bdd_ennval (f+g) :=
begin
  cases f_bdd with c hc ,
  cases g_bdd with d hd ,
  use (c+d) ,
  intros x ,
  exact add_le_add (hc x) (hd x) ,
end


lemma bdd_ennval_of_le_bdd_ennval {Œ± : Type*} {f g : Œ± ‚Üí ennreal}
  (hfg : f ‚â§ g) (g_bdd : bdd_ennval g) : bdd_ennval f :=
begin
  cases g_bdd with c hc ,
  use c ,
  intros x ,
  exact le_trans (hfg x) (hc x) ,
end


lemma bdd_ennval_of_bdd_Rval {Œ± : Type*} {f : Œ± ‚Üí ‚Ñù}
  (f_bdd : bdd_Rval f) : bdd_ennval (ennreal.of_real ‚àò f) :=
begin
  cases f_bdd with c hc ,
  use (c.to_nnreal) ,
  intros x ,
  apply ennreal.coe_mono ,
  apply real.to_nnreal_mono (le_trans (le_abs_self (f(x))) (hc x)) ,
end


lemma lim_R_of_lim_enn (s : ‚Ñï ‚Üí ennreal) (l : ennreal) 
  (hlim : tendsto s at_top (ùìù l)) (hfin : l ‚â† ‚ä§) : 
    tendsto (ennreal.to_real ‚àò s) at_top (ùìù (ennreal.to_real l)) :=
begin
  have cont_at : continuous_at ennreal.to_real l
    := continuous_on.continuous_at ennreal_to_real_continuous_on_nnreal (nnreal_nbhd_finite_ennreal l hfin) , 
  exact tendsto.comp cont_at hlim ,
end


lemma cont_R_of_cont_bdd_enn {Œ± : Type*} [topological_space Œ±]
  (f : Œ± ‚Üí ennreal) (f_cont : continuous f) (f_bdd : bdd_ennval f) :
    continuous (ennreal.to_real ‚àò f) :=
begin
  apply continuous_iff_continuous_at.mpr ,
  intros a ,
  set x := f(a) with hx ,
  have x_fin : x ‚â† ‚ä§ := finval_of_bdd_ennval f_bdd a , 
  have cont_at‚ÇÅ := continuous_iff_continuous_at.mp f_cont a ,
  have cont_at‚ÇÇ : continuous_at ennreal.to_real x
    := continuous_on.continuous_at ennreal_to_real_continuous_on_nnreal (nnreal_nbhd_finite_ennreal x x_fin) , 
  exact @continuous_at.comp Œ± ennreal ‚Ñù _ _ _ ennreal.to_real f a cont_at‚ÇÇ cont_at‚ÇÅ ,
end


lemma cont_enn_of_cont_R {Œ± : Type*} [topological_space Œ±] (f : Œ± ‚Üí ‚Ñù) (f_cont : continuous f) : 
  continuous (ennreal.of_real ‚àò f) 
    := continuous.comp (ennreal.continuous_of_real) f_cont 


lemma le_of_forall_pos_le_add_nnreal (a b : nnreal) : 
  (‚àÄ (Œµ : nnreal) , (Œµ > 0) ‚Üí (a ‚â§ b + Œµ)) ‚Üí a ‚â§ b :=
begin
  exact nnreal.le_of_forall_pos_le_add ,
end


lemma tendsto_of_ev_same {Œ± Œ≤ : Type*} {FŒ± : filter Œ±} {FŒ≤ : filter Œ≤}
  (f g : Œ± ‚Üí Œ≤) (h_ev_eq : ‚àÉ (S : set Œ±) , S ‚àà FŒ±.sets ‚àß 
    ‚àÄ x , x ‚àà S ‚Üí f(x) = g(x) ) :
      tendsto f FŒ± FŒ≤ ‚Üí tendsto g FŒ± FŒ≤ :=
begin
  intro tends_f ,
  cases h_ev_eq with S hS ,
  intros T hT ,
  have key := FŒ±.inter_sets hS.1 (tends_f hT),
  have eq_fg : S ‚à© f‚Åª¬π' T = S ‚à© g‚Åª¬π' T ,
  { ext x ,
    simp only [mem_inter_eq, mem_preimage, and.congr_right_iff] ,
    intro hxS ,
    rwa hS.2 x , } ,  
  rw eq_fg at key ,
  exact FŒ±.sets_of_superset key (set.inter_subset_right _ _ ) ,
end


lemma lim_R_of_ev_same (x y : ‚Ñï ‚Üí ‚Ñù)
  (hevsame : ‚àÉ (m : ‚Ñï), ‚àÄ (k : ‚Ñï) , k ‚â• m ‚Üí x(k) = y(k))
  (hlim : tendsto x at_top (ùìù 0)) :
    tendsto y at_top (ùìù 0) :=
begin
  apply tendsto_of_ev_same x y ,
  { cases hevsame with m hm ,
    set S := { k : ‚Ñï | k ‚â• m } ,
    have mem : S ‚àà at_top.sets := mem_at_top m ,
    use [ S , mem ] ,
    exact hm , } , 
  exact hlim ,
end


lemma lim_enn_of_ev_same (x y : ‚Ñï ‚Üí ennreal)
  (hevsame : ‚àÉ (m : ‚Ñï), ‚àÄ (k : ‚Ñï) , k ‚â• m ‚Üí x(k) = y(k))
  (hlim : tendsto x at_top (ùìù 0)) :
    tendsto y at_top (ùìù 0) :=
begin
  apply tendsto_of_ev_same x y ,
  { cases hevsame with m hm ,
    set S := { k : ‚Ñï | k ‚â• m } ,
    have mem : S ‚àà at_top.sets := mem_at_top m ,
    use [ S , mem ] ,
    exact hm , } , 
  exact hlim ,
end


lemma of_real_lt_of_lt_to_real {x : ‚Ñù} {z : ennreal} (x_lt_z : x < z.to_real) (x_nn : 0 ‚â§ x) : 
  ennreal.of_real(x) < z :=
begin
  by_cases z_top : z = ‚ä§ ,
  { rw z_top ,
    exact lt_top_iff_ne_top.mpr (@ennreal.of_real_ne_top x) , } ,
  { have le : ennreal.of_real x ‚â§ z := ennreal.of_real_le_of_le_to_real (le_of_lt x_lt_z) ,
    have neq : ennreal.of_real x ‚â† z ,
    { by_contra con ,
      push_neg at con ,
      rw ‚Üêcon at x_lt_z ,
      rw (ennreal.to_real_of_real x_nn) at x_lt_z ,
      linarith , } ,
    exact (ne.le_iff_lt neq).mp le , } ,
end


lemma of_real_mono : monotone ennreal.of_real :=
begin
  intros x y hxy ,
  exact ennreal.of_real_le_of_real hxy ,
end


lemma of_real_lt_of_lt {x y : ‚Ñù} (x_nn : 0 ‚â§ x) (x_lt_y : x < y) : 
  ennreal.of_real x < ennreal.of_real y :=
begin
  have ne : ennreal.of_real x ‚â† ennreal.of_real y ,
  { intros h ,
    have rw_x : (ennreal.of_real x).to_real = x := ennreal.to_real_of_real x_nn ,
    have rw_y : (ennreal.of_real y).to_real = y := ennreal.to_real_of_real (le_of_lt (lt_of_le_of_lt x_nn x_lt_y)) ,
    have eq : (ennreal.of_real x).to_real = (ennreal.of_real y).to_real := congr_arg ennreal.to_real h ,
    rw [rw_x , rw_y] at eq ,
    apply ne_of_lt x_lt_y ,
    rwa eq at x_lt_y , } ,
  have le : ennreal.of_real x ‚â§ ennreal.of_real y := of_real_mono (le_of_lt x_lt_y) ,
  exact (ne.le_iff_lt).mp le ,
end


lemma of_real_lt_of_real {x y : ‚Ñù} (hxy : ennreal.of_real x < ennreal.of_real y) : x < y :=
begin
  have x_ne_top : ennreal.of_real x ‚â† ‚ä§ := ennreal.of_real_ne_top ,
  have y_gt' : 0 < ennreal.of_real y := pos_of_gt hxy ,
  have y_gt : 0 < y := ennreal.of_real_pos.mp y_gt' ,
  by_contra x_too_large ,
  simp only [not_lt] at x_too_large , 
  have x_ge := ennreal.of_real_le_of_real x_too_large ,
  exact not_lt.mpr (le_refl (ennreal.of_real x)) (lt_of_lt_of_le hxy x_ge) ,
end



end portmanteau_comeonlean_lemmas

end portmanteau

